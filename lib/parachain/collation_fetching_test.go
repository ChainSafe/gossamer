package parachain

import (
	"testing"

	"github.com/ChainSafe/gossamer/lib/common"
	"github.com/stretchr/testify/require"
)

func TestEncodeCollationFetchingRequest(t *testing.T) {
	collationFetchingRequest := CollationFetchingRequest{
		RelayParent: common.MustHexToHash("0x677811d2f3ded2489685468dbdb2e4fa280a249fba9356acceb2e823820e2c19"),
		ParaID:      5,
	}

	actualEncode, err := collationFetchingRequest.Encode()
	require.NoError(t, err)

	expextedEncode := common.MustHexToBytes("0x677811d2f3ded2489685468dbdb2e4fa280a249fba9356acceb2e823820e2c1905000000")
	require.Equal(t, expextedEncode, actualEncode)
}

func TestCollationFetchingResponse(t *testing.T) {
	t.Parallel()

	testHash := common.MustHexToHash("0x677811d2f3ded2489685468dbdb2e4fa280a249fba9356acceb2e823820e2c19")

	var collatorID CollatorID
	tempCollatID := common.MustHexToBytes("0x48215b9d322601e5b1a95164cea0dc4626f545f98343d07f1551eb9543c4b147")
	copy(collatorID[:], tempCollatID)

	var collatorSignature CollatorSignature
	tempSignature := common.MustHexToBytes(testDataStatement["collatorSignature"])
	copy(collatorSignature[:], tempSignature)

	collation := Collation{
		CandidateReceipt: CandidateReceipt{
			Descriptor: CandidateDescriptor{
				ParaID:                      uint32(1),
				RelayParent:                 testHash,
				Collator:                    collatorID,
				PersistedValidationDataHash: testHash,
				PovHash:                     testHash,
				ErasureRoot:                 testHash,
				Signature:                   collatorSignature,
				ParaHead:                    testHash,
				ValidationCodeHash:          ValidationCodeHash(testHash),
			},
			CommitmentsHash: testHash,
		},
		PoV: PoV{1, 2, 3},
	}

	// expected encoding is generated by running rust test code:
	// fn collation_fetching_response() {
	// 	let test_hash: H256 = H256::from_str(
	//	"0x677811d2f3ded2489685468dbdb2e4fa280a249fba9356acceb2e823820e2c19"
	//	).unwrap();
	// 	let collator_result = sr25519::Public::from_string(
	// 		"0x48215b9d322601e5b1a95164cea0dc4626f545f98343d07f1551eb9543c4b147",
	// 	);
	// 	if collator_result.is_err() {
	// 		println!(
	// 			"collator_result.unwrap_err()=> {:?}",
	// 			collator_result.unwrap_err()
	// 		);
	// 	}
	// 	let collator = CollatorId::from(collator_result.unwrap());
	// 	let collsign = CollatorSignature::from(sr25519::Signature([
	// 		198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89,
	// 		104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6,
	// 		152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190,
	// 		116, 184, 148, 207, 27, 134,
	// 	]));
	// 	let candidate_descriptor = CandidateDescriptor {
	// 		para_id: 1.into(),
	// 		relay_parent: test_hash,
	// 		collator: collator.clone(),
	// 		persisted_validation_data_hash: test_hash,
	// 		pov_hash: test_hash,
	// 		erasure_root: test_hash,
	// 		signature: collsign.clone(),
	// 		para_head: test_hash,
	// 		validation_code_hash: ValidationCodeHash::from(test_hash),
	// 	};
	// 	let candidate_receipt = CandidateReceipt{
	// 		descriptor: candidate_descriptor,
	// 		commitments_hash: test_hash
	// 	};
	// 	let pov = PoV{
	// 		block_data: vec![1, 2, 3].into()
	// 	};
	// 	let collation_fetching_response = CollationFetchingResponse::Collation(
	// 		candidate_receipt, pov
	// 	);
	// 	println!(
	// 		"CollationFetchingResponse encode => {:?}\n\n",
	// 		collation_fetching_response.encode()
	// 	);
	// }
	encodedValue := common.MustHexToBytes(testDataCollationProtocol["collationFetchigResponse"])

	t.Run("encode_collation_fetching_response", func(t *testing.T) {
		t.Parallel()

		responseVDT := NewCollationFetchingResponse()
		err := responseVDT.Set(collation)
		require.NoError(t, err)

		actualEncode, err := responseVDT.Encode()
		require.NoError(t, err)

		require.Equal(t, encodedValue, actualEncode)
	})

	t.Run("Decode_collation_fetching_response", func(t *testing.T) {
		t.Parallel()

		responseVDT := NewCollationFetchingResponse()
		err := responseVDT.Decode(encodedValue)
		require.NoError(t, err)

		actualData, err := responseVDT.Value()
		require.NoError(t, err)

		require.EqualValues(t, collation, actualData)
	})
}
