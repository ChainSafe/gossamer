package parachain

import (
	"fmt"
	"testing"

	"github.com/ChainSafe/gossamer/lib/common"
	"github.com/ChainSafe/gossamer/lib/keystore"
	"github.com/ChainSafe/gossamer/pkg/scale"
	"github.com/gtank/merlin"
	"github.com/stretchr/testify/require"
)

func TestEncodeApprovalDistributionMessageAssignmentModulo(t *testing.T) {
	approvalDistributionMessage, err := NewApprovalDistributionMessageVDT()
	require.NoError(t, err)
	hash := common.Hash{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}

	// expected encoding is generated by running rust test code:
	// fn try_msg_assignments_encode() {
	//	let hash = Hash::repeat_byte(0xAA);
	//
	//	let validator_index = ValidatorIndex(1);
	//	let cert = fake_assignment_cert(hash, validator_index);
	//	let assignments = vec![(cert.clone(), 4u32)];
	//	let msg = protocol_v1::ApprovalDistributionMessage::Assignments(assignments.clone());
	//
	//	let emsg = msg.encode();
	//	println!("encode: {:?}", emsg);
	//}
	expectedEncoding := []byte{0, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
		170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 1, 0, 0, 0, 0, 1, 0, 0, 0, 46,
		144, 255, 239, 40, 55, 228, 78, 222, 92, 94, 244, 137, 127, 156, 251, 80, 27, 143, 38, 117, 132, 171, 66, 234,
		113, 41, 83, 39, 175, 191, 85, 195, 149, 8, 236, 143, 153, 239, 9, 171, 76, 214, 28, 120, 70, 136, 160, 199,
		132, 159, 244, 32, 224, 186, 80, 27, 142, 161, 118, 188, 133, 51, 8, 229, 197, 156, 193, 28, 201, 15, 144, 143,
		147, 107, 212, 52, 152, 1, 64, 108, 217, 44, 155, 243, 128, 215, 226, 46, 64, 175, 18, 193, 38, 156, 2, 4, 0,
		0, 0}

	approvalDistributionMessage.Set(Assignments{
		Assignments: []Assignment{{
			IndirectAssignmentCert: fakeAssignmentCertModulo(t, hash, ValidatorIndex(1)),
			CandidateIndex:         4,
		}},
	})

	encodedMessage, err := scale.Marshal(approvalDistributionMessage)
	require.NoError(t, err)

	require.Equal(t, len(expectedEncoding), len(encodedMessage))
	// Note we don't test bytes 44-139 since they are generated by cert signing and are different each time
	require.Equal(t, expectedEncoding[:43], encodedMessage[:43])
	require.Equal(t, expectedEncoding[139:], encodedMessage[139:])
}

func TestEncodeApprovalDistributionMessageAssignmentDelay(t *testing.T) {
	approvalDistributionMessage, err := NewApprovalDistributionMessageVDT()
	require.NoError(t, err)
	hash := common.Hash{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}

	expectedEncoding := []byte{0, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 2, 0, 0, 0, 1, 2, 0, 0, 0, 184, 188, 137, 254, 98, 55, 199, 177, 71, 182, 82, 19, 111, 53, 18, 206, 196, 47, 84, 191, 15, 38, 227, 142, 252, 243, 185, 74, 253, 240, 211, 81, 164, 62, 152, 74, 252, 218, 240, 78, 42, 239, 92, 18, 125, 185, 4, 108, 13, 234, 80, 54, 234, 99, 196, 111, 146, 155, 247, 163, 51, 96, 143, 0, 106, 140, 60, 208, 226, 159, 76, 57, 13, 219, 16, 89, 75, 202, 155, 174, 223, 206, 56, 220, 75, 123, 226, 170, 144, 109, 47, 123, 119, 125, 85, 7, 2, 0, 0, 0}

	approvalDistributionMessage.Set(Assignments{
		Assignments: []Assignment{{
			IndirectAssignmentCert: fakeAssignmentCertDelay(t, hash, ValidatorIndex(2)),
			CandidateIndex:         2,
		}},
	})

	encodedMessage, err := scale.Marshal(approvalDistributionMessage)
	require.NoError(t, err)

	require.Equal(t, len(expectedEncoding), len(encodedMessage))
	// Note we don't test bytes 44-139 since they are generated by cert signing and are different each time
	require.Equal(t, expectedEncoding[:43], encodedMessage[:43])
	require.Equal(t, expectedEncoding[139:], encodedMessage[139:])
}

func TestEncodeApprovalDistributionMessageApprovals(t *testing.T) {
	approvalDistributionMessage, err := scale.NewVaryingDataType(Assignments{}, Approvals{})
	require.NoError(t, err)
	hash := common.Hash{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}

	expectedEncoding := []byte{1, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
		170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 2, 0, 0, 0, 3, 0, 0, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

	approvalDistributionMessage.Set(Approvals{
		Approvals: []IndirectSignedApprovalVote{{
			BlockHash:      hash,
			CandidateIndex: CandidateIndex(2),
			ValidatorIndex: ValidatorIndex(3),
			Signature: ValidatorSignature{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
				1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
				1, 1, 1, 1, 1, 1},
		}},
	})

	encodedMessage, err := scale.Marshal(approvalDistributionMessage)
	require.NoError(t, err)

	require.Equal(t, expectedEncoding, encodedMessage)
}

func TestDecodeApprovalDistributionMessageAssignmentModulo(t *testing.T) {
	//approvalDistributionMessage, err := NewApprovalDistributionMessageVDT()
	//require.NoError(t, err)
	//hash := common.Hash{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
	//	0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}

	// encoding is generated by running rust test code:
	// fn try_msg_assignments_encode() {
	//	let hash = Hash::repeat_byte(0xAA);
	//
	//	let validator_index = ValidatorIndex(1);
	//	let cert = fake_assignment_cert(hash, validator_index);
	//	let assignments = vec![(cert.clone(), 4u32)];
	//	let msg = protocol_v1::ApprovalDistributionMessage::Assignments(assignments.clone());
	//
	//	let emsg = msg.encode();
	//	println!("encode: {:?}", emsg);
	//}
	encoding := []byte{0, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170,
		170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 1, 0, 0, 0, 0, 1, 0, 0, 0, 46,
		144, 255, 239, 40, 55, 228, 78, 222, 92, 94, 244, 137, 127, 156, 251, 80, 27, 143, 38, 117, 132, 171, 66, 234,
		113, 41, 83, 39, 175, 191, 85, 195, 149, 8, 236, 143, 153, 239, 9, 171, 76, 214, 28, 120, 70, 136, 160, 199,
		132, 159, 244, 32, 224, 186, 80, 27, 142, 161, 118, 188, 133, 51, 8, 229, 197, 156, 193, 28, 201, 15, 144, 143,
		147, 107, 212, 52, 152, 1, 64, 108, 217, 44, 155, 243, 128, 215, 226, 46, 64, 175, 18, 193, 38, 156, 2, 4, 0,
		0, 0}

	var approvalDistributionMessage ApprovalDistributionMessage
	err := scale.Unmarshal(encoding, &approvalDistributionMessage)
	require.NoError(t, err)
	fmt.Printf("dec %v\n", approvalDistributionMessage)

	//approvalDistributionMessage.Set(Assignments{
	//	Assignments: []Assignment{{
	//		IndirectAssignmentCert: fakeAssignmentCertModulo(t, hash, ValidatorIndex(1)),
	//		CandidateIndex:         4,
	//	}},
	//})
	//
	//encodedMessage, err := scale.Marshal(approvalDistributionMessage)
	//require.NoError(t, err)
	//
	//require.Equal(t, len(expectedEncoding), len(encodedMessage))
	//// Note we don't test bytes 44-139 since they are generated by cert signing and are different each time
	//require.Equal(t, expectedEncoding[:43], encodedMessage[:43])
	//require.Equal(t, expectedEncoding[139:], encodedMessage[139:])
}

func fakeAssignmentCertModulo(t *testing.T, blockHash common.Hash, validator ValidatorIndex) IndirectAssignmentCert {
	msg := []byte(`WhenParachains?`)
	keyring, err := keystore.NewSr25519Keyring()
	require.NoError(t, err)

	transcript := merlin.NewTranscript(RELAY_VRF_MODULO_CONTEXT)
	transcript.AppendMessage(msg, []byte{})

	output, proof, err := keyring.KeyAlice.VrfSign(transcript)
	require.NoError(t, err)

	assignmentCertKind, err := NewAssignmentCertKindVDT()
	require.NoError(t, err)
	assignmentCertKind.Set(RelayVRFModulo{Sample: 1})
	return IndirectAssignmentCert{
		BlockHash: blockHash,
		Validator: validator,
		Cert: AssignmentCert{
			Kind: AssignmentCertKind(assignmentCertKind),
			Vrf: VrfSignature{
				Output: output,
				Proof:  proof,
			},
		},
	}
}

func fakeAssignmentCertDelay(t *testing.T, blockHash common.Hash, validator ValidatorIndex) IndirectAssignmentCert {
	msg := []byte(`WhenParachains?`)
	keyring, err := keystore.NewSr25519Keyring()
	require.NoError(t, err)

	transcript := merlin.NewTranscript(RELAY_VRF_DELAY_CONTEXT)
	transcript.AppendMessage(msg, []byte{})

	output, proof, err := keyring.KeyAlice.VrfSign(transcript)
	require.NoError(t, err)

	assignmentCertKind, err := NewAssignmentCertKindVDT()
	require.NoError(t, err)
	assignmentCertKind.Set(RelayVRFDelay{CoreIndex: 2})
	return IndirectAssignmentCert{
		BlockHash: blockHash,
		Validator: validator,
		Cert: AssignmentCert{
			Kind: AssignmentCertKind(assignmentCertKind),
			Vrf: VrfSignature{
				Output: output,
				Proof:  proof,
			},
		},
	}
}
