package parachain

import (
	_ "embed"
	"fmt"
	"github.com/ChainSafe/gossamer/lib/common"
	"github.com/ChainSafe/gossamer/pkg/scale"
	"github.com/stretchr/testify/require"
	"gopkg.in/yaml.v3"
	"testing"
)

//go:embed testdata/validation_protocol.yaml

var testValidationProtocolHexRaw string

var testValidationProtocolHex map[string]string

func init() {
	err := yaml.Unmarshal([]byte(testValidationProtocolHexRaw), &testValidationProtocolHex)
	if err != nil {
		fmt.Printf("Error unmarshaling test data: %s\n", err)
		return
	}
}

func TestDecodeValidationProtocolApprovalDistributionMessageAssignmentModulo(t *testing.T) {
	// expected encoding is generated by running rust test code:
	/*
		fn try_msg_assignments_encode() {
			let hash = Hash::repeat_byte(0xAA);

			let validator_index = ValidatorIndex(1);
			let cert = fake_assignment_cert(hash, validator_index);
			println!("hash: {:#?}", hash);
			let assignments = vec![(cert.clone(), 4u32)];

		let msg = protocol_v1::ApprovalDistributionMessage::Assignments(assignments.clone());

		println!("MSG: {:#?}", msg);
		let emsg = msg.encode();
		println!("encode: {:?}", emsg);
		let val_proto = protocol_v1::ValidationProtocol::ApprovalDistribution(msg.clone());
		println!("encode validation proto => {:?}\n\n", val_proto.encode());

		}
	*/
	hexEnc := common.BytesToHex([]byte{4, 0, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 1, 0, 0, 0, 0, 1, 0, 0, 0, 60, 171, 2, 174, 183, 34, 93, 199, 176, 106, 120, 50, 236, 49, 188, 136, 244, 101, 106, 142, 14, 121, 197, 13, 219, 253, 245, 27, 79, 209, 75, 43, 36, 178, 31, 165, 74, 56, 147, 232, 117, 47, 141, 8, 208, 230, 217, 40, 97, 140, 155, 210, 159, 181, 243, 91, 192, 150, 143, 93, 64, 120, 105, 2, 180, 161, 251, 85, 241, 239, 111, 252, 238, 52, 237, 217, 184, 104, 122, 18, 89, 49, 95, 28, 32, 54, 81, 222, 77, 81, 15, 196, 94, 134, 56, 6, 4, 0, 0, 0})
	fmt.Printf("hex %v\n", hexEnc)

	encoding := common.MustHexToBytes(testValidationProtocolHex["approvalDistributionMessageAssignments"])
	validationProtocol := NewValidationProtocolVDT()

	err := scale.Unmarshal(encoding, &validationProtocol)
	require.NoError(t, err)

	validationProtocolDecoded, err := validationProtocol.Value()
	require.NoError(t, err)
	fmt.Printf("decoded %#v\n", validationProtocolDecoded)
}

func TestDecodeValidationProtocolApprovalDistributionMessageApprovals(t *testing.T) {
	/*
		fn try_msg_approvals_encode() {
			let hash = Hash::repeat_byte(0xAA);
			let candidate_index = 0u32;
			let validator_index = ValidatorIndex(0);
			let approval = IndirectSignedApprovalVote {
				block_hash: hash,
				candidate_index,
				validator: validator_index,
				signature: dummy_signature(),
			};
			let msg = protocol_v1::ApprovalDistributionMessage::Approvals(vec![approval.clone()]);

			println!("MSG: {:#?}", msg);
			let emsg = msg.encode();
			println!("encode: {:?}", emsg);

			let val_proto = protocol_v1::ValidationProtocol::ApprovalDistribution(msg.clone());
			println!("encode validation proto => {:?}\n\n", val_proto.encode());

		}

	*/
	hexEnc := common.BytesToHex([]byte{4, 1, 4, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1})
	fmt.Printf("hex %v\n", hexEnc)

	encoding := common.MustHexToBytes(testValidationProtocolHex["approvalDistributionMessageApprovals"])
	validationProtocol := NewValidationProtocolVDT()

	err := scale.Unmarshal(encoding, &validationProtocol)
	require.NoError(t, err)

	validationProtocolDecoded, err := validationProtocol.Value()
	require.NoError(t, err)
	fmt.Printf("decoded %#v\n", validationProtocolDecoded)
}

func TestDecodeValidationProtocolStatementDistrubitionMessageStatement(t *testing.T) {
	/*
		fn try_validation_protocol_statement_distribution_full_statement() {
			let hash1 = Hash::repeat_byte(5);
			let val_sign = ValidatorSignature::from(
				Signature([198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89,
					104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152,
					216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184,
					148, 207, 27, 134]));
			let keystore: KeystorePtr = Arc::new(LocalKeystore::in_memory());
			let collator_result = Keystore::sr25519_generate_new(
				&*keystore,
				ValidatorId::ID,
				Some(&Sr25519Keyring::Alice.to_seed()),
			);
			let collator = collator_result.unwrap();
			let collsign = CollatorSignature::from(Signature([198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89,
				104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152,
				216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184,
				148, 207, 27, 134]));
			let candidate_descriptor = CandidateDescriptor{
				para_id: 1.into(),
				relay_parent: hash1,
				collator: polkadot_primitives::CollatorId::from(collator),
				persisted_validation_data_hash: hash1,
				pov_hash: hash1,
				erasure_root: hash1,
				signature: collsign,
				para_head: hash1,
				validation_code_hash: ValidationCodeHash::from(hash1)
			};
			let commitments_new = CandidateCommitments{
				upward_messages: vec![vec![1, 2, 3]].try_into().expect("error - upward_messages"),
				horizontal_messages: vec![].try_into().expect("error - horizontal_messages"),
				head_data: HeadData(vec![1, 2, 3]),
				hrmp_watermark: 0_u32,
				new_validation_code: ValidationCode(vec![1, 2, 3]).try_into().expect("error - new_validation_code"),
				processed_downward_messages: 5
			};
			let committed_candidate_receipt = CommittedCandidateReceipt {
				 descriptor: candidate_descriptor, commitments: commitments_new };
			let statement_second = Statement::Seconded(committed_candidate_receipt);
			let unchecked_signed_full_statement_second = UncheckedSignedFullStatement::new(
				statement_second, ValidatorIndex(5), val_sign.clone());
			let sdm_statement_second = protocol_v1::StatementDistributionMessage::Statement(hash1,
				unchecked_signed_full_statement_second);
			let validation_sdm_statement = protocol_v1::ValidationProtocol::StatementDistribution(sdm_statement_second);
			println!("encode validation SecondedStatement => {:?}\n\n", validation_sdm_statement.encode());
		}
	*/
	hexEnc := common.BytesToHex([]byte{3, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 212, 53, 147, 199, 21, 253, 211, 28, 97, 20, 26, 189, 4, 169, 159, 214, 130, 44, 133, 88, 133, 76, 205, 227, 154, 86, 132, 231, 165, 109, 162, 125, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89, 104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184, 148, 207, 27, 134, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 12, 1, 2, 3, 0, 1, 12, 1, 2, 3, 12, 1, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89, 104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184, 148, 207, 27, 134})
	fmt.Printf("hex %v\n", hexEnc)

	encoding := common.MustHexToBytes(testValidationProtocolHex["statementDistributionMessageStatement"])
	validationProtocol := NewValidationProtocolVDT()

	err := scale.Unmarshal(encoding, &validationProtocol)
	require.NoError(t, err)

	validationProtocolDecoded, err := validationProtocol.Value()
	require.NoError(t, err)
	fmt.Printf("decoded %#v\n", validationProtocolDecoded)

}

func TestDecodeValidationProtocolStatementDistrubitionMessageStatementScrap(t *testing.T) {
	enc := []byte{0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 212, 53, 147, 199, 21, 253, 211, 28, 97, 20, 26, 189, 4, 169, 159, 214, 130, 44, 133, 88, 133, 76, 205, 227, 154, 86, 132, 231, 165, 109, 162, 125, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89, 104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184, 148, 207, 27, 134, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 12, 1, 2, 3, 0, 1, 12, 1, 2, 3, 12, 1, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89, 104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184, 148, 207, 27, 134}
	hexEnc := common.BytesToHex(enc)
	fmt.Printf("hex %v\n", hexEnc)

	//encoding := common.MustHexToBytes(testValidationProtocolHex["statementDistributionMessageStatement"])
	validationProtocol := NewStatementDistributionVDT()

	err := scale.Unmarshal(enc, &validationProtocol)
	require.NoError(t, err)

	//validationProtocolDecoded, err := validationProtocol.Value()
	//require.NoError(t, err)
	//fmt.Printf("decoded %#v\n", validationProtocolDecoded)
	fmt.Printf("decoded %v\n", validationProtocol)
}

func TestDecodeValidationProtocolStatementDistributionMessageLargeStatement(t *testing.T) {

	/*
		fn try_validation_protocol_statement_distribution() {

			let hash1 = Hash::repeat_byte(5);
			let val_sign = ValidatorSignature::from(
				Signature([198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89,
					104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152,
					216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184,
					148, 207, 27, 134]));
				    let sdm_large_statement = protocol_v1::StatementDistributionMessage::LargeStatement(StatementMetadata{
				        relay_parent: hash1,
				        candidate_hash: CandidateHash(hash1),
				        signed_by: ValidatorIndex(5_u32),
				        signature: val_sign.clone(),
				    });
					let validation_sdm_large_statement = protocol_v1::ValidationProtocol::StatementDistribution(sdm_large_statement);

				    println!("encode validation SecondedStatementWithLargePayload => {:?}\n\n", validation_sdm_large_statement.encode());

		}

	*/
	hexEnc := common.BytesToHex([]byte{3, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 198, 124, 185, 59, 240, 163, 111, 206, 227, 210, 157, 232, 166, 166, 154, 117, 150, 89, 104, 10, 207, 72, 100, 117, 224, 162, 85, 42, 95, 190, 216, 126, 69, 173, 206, 95, 41, 6, 152, 216, 89, 96, 149, 114, 43, 51, 89, 146, 39, 247, 70, 31, 81, 175, 134, 23, 200, 190, 116, 184, 148, 207, 27, 134})
	fmt.Printf("hex %v\n", hexEnc)

	encoding := common.MustHexToBytes(testValidationProtocolHex["statementDistributionMessageLargeStatement"])
	validationProtocol := NewValidationProtocolVDT()

	err := scale.Unmarshal(encoding, &validationProtocol)
	require.NoError(t, err)

	validationProtocolDecoded, err := validationProtocol.Value()
	require.NoError(t, err)
	fmt.Printf("decoded %#v\n", validationProtocolDecoded)
}

func TestDecodeValidationProtocolBitfieldDistributionMessage(t *testing.T) {
	/*
		fn try_validation_protocol_bitfield_distribution_a() {
			let mut bitvec = default_bitvec(2);
				bitvec.set(0, true);
				bitvec.set(1, true);
			let hash_a :Hash = [0; 32].into();
			let keystore: KeystorePtr = Arc::new(MemoryKeystore::new());
			let payload = AvailabilityBitfield(bitvec![u8, bitvec::order::Lsb0; 1u8; 32]);
			let signing_context = SigningContext { session_index: 1, parent_hash: hash_a.clone() };
			let validator_0 =
				Keystore::sr25519_generate_new(&*keystore, ValidatorId::ID, None).expect("key created");

				let valid_signed = Signed::<AvailabilityBitfield>::sign(
					&keystore,
					payload,
					&signing_context,
					ValidatorIndex(0),
					&validator_0.into(),
				)
				.ok()
				.flatten()
				.expect("should be signed");

			let bitfield_distribition_message = protocol_v1::BitfieldDistributionMessage::Bitfield(
				hash_a,
				valid_signed.into(),
			);
			let val_proto = ValidationProtocol::BitfieldDistribution(bitfield_distribition_message.clone());
			println!("encode validation proto => {:?}\n\n", val_proto.encode());
			println!("encode validation BitfieldDistributionMessage => {:?}\n\n", bitfield_distribition_message.encode());

		}
	*/
	//encoding := []byte{0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 3, 0, 0, 0, 0, 204, 16, 186, 86, 148, 93, 197, 173, 242, 26, 102, 223, 164, 226, 92, 121, 4, 233, 233, 215, 58, 44, 160, 135, 31, 169, 229, 215, 224, 45, 144, 64, 65, 87, 222, 125, 226, 49, 59, 9, 145, 109, 178, 48, 132, 41, 174, 234, 12, 253, 69, 101, 5, 221, 241, 214, 125, 190, 64, 176, 23, 76, 48, 129}
	hexEnc := common.BytesToHex([]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 255, 255, 255, 255, 0, 0, 0, 0, 204, 79, 12, 2, 31, 8, 66, 43, 170, 96, 31, 189, 210, 218, 207, 152, 247, 210, 214, 74, 84, 46, 21, 12, 137, 167, 7, 72, 143, 135, 26, 102, 115, 233, 170, 137, 136, 21, 75, 117, 16, 13, 185, 148, 230, 163, 40, 191, 202, 73, 215, 235, 163, 236, 223, 131, 224, 118, 107, 143, 193, 174, 251, 138})
	fmt.Printf("hex %v\n", hexEnc)

	encoding := common.MustHexToBytes(testValidationProtocolHex["bitfieldDistribution"])
	validationProtocol := NewValidationProtocolVDT()

	err := scale.Unmarshal(encoding, &validationProtocol)
	require.NoError(t, err)

	validationProtocolDecoded, err := validationProtocol.Value()
	require.NoError(t, err)
	fmt.Printf("decoded %#v\n", validationProtocolDecoded)
}
