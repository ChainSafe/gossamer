import _classPrivateFieldLooseBase from "@babel/runtime/helpers/esm/classPrivateFieldLooseBase";
import _classPrivateFieldLooseKey from "@babel/runtime/helpers/esm/classPrivateFieldLooseKey";
// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { sanitize, Struct } from '@polkadot/types-codec';
import { getTypeDef, TypeDefInfo, withTypeString } from '@polkadot/types-create';
import { assert, assertUnreachable, isNumber, isString, logger, objectSpread, stringCamelCase, stringify, stringPascalCase } from '@polkadot/util';
const l = logger('PortableRegistry'); // Just a placeholder for a type.unrwapOr()

const TYPE_UNWRAP = {
  toNumber: () => -1
}; // Alias the primitive enum with out known values

const PRIMITIVE_ALIAS = {
  Char: 'u32',
  // Rust char is 4-bytes
  Str: 'Text'
}; // These are types where we have a specific decoding/encoding override + helpers

const PATHS_ALIAS = splitNamespace([// these have a specific encoding or logic (for pallets)
'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding
'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // ethereum overrides (Frontier, Moonbeam, Polkadot claims)
'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress', // shorten some well-known types
'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!
'ink_env::types::*']); // Mappings for types that should be converted to set via BitVec

const PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']); // These we never use these as top-level names, they are wrappers

const WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec', 'WrapperKeepOpaque', 'WrapperOpaque']; // These are reserved and/or conflicts with built-in Codec or JS definitions

const RESERVED = ['entries', 'hash', 'keys', 'new', 'size']; // Remove these from all paths at index 1

const PATH_RM_INDEX_1 = ['generic', 'misc', 'pallet', 'traits', 'types'];

function splitNamespace(values) {
  return values.map(v => v.split('::'));
}

function createNamespace({
  path
}) {
  return sanitizeDocs(path).join('::');
}

function sanitizeDocs(docs) {
  return docs.map(d => d.toString());
}

function matchParts(first, second) {
  return first.length === second.length && first.every((a, index) => {
    const b = second[index].toString();

    if (a === '*' || a === b) {
      return true;
    }

    if (a.includes('*') && a.includes('_') && b.includes('_')) {
      let suba = a.split('_');
      let subb = b.split('_'); // match initial *'s to multiples if we have a match for the other

      if (suba[0] === '*') {
        const indexOf = subb.indexOf(suba[1]);

        if (indexOf !== -1) {
          suba = suba.slice(1);
          subb = subb.slice(indexOf);
        }
      } // check for * matches at the end, adjust accordingly


      if (suba.length === 2 && suba[1] === '*' && suba[0] === subb[0]) {
        return true;
      }

      return matchParts(suba, subb);
    }

    return false;
  });
} // check if the path matches the PATHS_ALIAS (with wildcards)


function getAliasPath(path) {
  // TODO We need to handle ink! Balance in some way
  return path.length && PATHS_ALIAS.some(a => matchParts(a, path)) ? path[path.length - 1].toString() : null;
}

function hasNoDupes(input) {
  for (let i = 0; i < input.length; i++) {
    const [ai, an] = input[i];

    for (let j = 0; j < input.length; j++) {
      const [bi, bn] = input[j]; // if the indexes are not the same and the names match, we have a dupe

      if (ai !== bi && an === bn) {
        return false;
      }
    }
  }

  return true;
}

function removeDuplicateNames(lookup, names) {
  const rewrite = {};
  return names.map(([lookupIndex, name, params]) => {
    if (!name) {
      return null;
    } // those where the name is matching (since name is filtered, these all do have names)


    const allSame = names.filter(([, oName]) => name === oName); // are there among matching names

    const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber()))); // everything matches, we can combine these

    if (!anyDiff || !allSame[0][2].length) {
      return [lookupIndex, name, params];
    } // find the first parameter that yields differences


    const paramIdx = allSame[0][2].findIndex(({
      type
    }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type))); // No param found that is different

    if (paramIdx === -1) {
      return [lookupIndex, name, params];
    } // see if using the param type helps


    const adjusted = new Array(allSame.length);

    for (let i = 0; i < allSame.length; i++) {
      const [oIndex, oName, oParams] = allSame[i];
      const {
        def,
        path
      } = lookup.getSiType(oParams[paramIdx].type.unwrap());

      if (!def.isPrimitive && !path.length) {
        return null;
      }

      adjusted[i] = [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`, params];
    }

    if (hasNoDupes(adjusted)) {
      for (let i = 0; i < adjusted.length; i++) {
        const [index, name] = adjusted[i];
        rewrite[index] = name;
      }

      return [lookupIndex, name, params];
    }

    return null;
  }).filter(n => !!n).map(([lookupIndex, name, params]) => [lookupIndex, rewrite[lookupIndex] || name, params]);
}

function extractName(types, {
  id,
  type: {
    params,
    path
  }
}) {
  // if we have no path or determined as a wrapper, we just skip it
  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {
    return null;
  }

  const parts = path.map(p => stringPascalCase(p)).filter((p, index) => {
    const lower = p.toLowerCase();
    return ( // Remove ::{generic, misc, pallet, traits, types}::
    index !== 1 || !PATH_RM_INDEX_1.includes(lower)) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest
    // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress
    index === path.length - 1 || lower !== path[index + 1].toLowerCase());
  });
  let typeName = parts.join(''); // do magic for RawOrigin lookup, e.g. pallet_collective::RawOrigin

  if (parts.length === 2 && parts[1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {
    const instanceType = types[params[1].type.unwrap().toNumber()];

    if (instanceType.type.path.length === 2) {
      typeName = `${typeName}${instanceType.type.path[1].toString()}`;
    }
  }

  return [id.toNumber(), typeName, params];
}

function registerTypes(lookup, lookups, names, params) {
  // Register the types we extracted
  lookup.registry.register(lookups); // Try and extract the AccountId/Address/Signature type from UncheckedExtrinsic

  if (params.SpRuntimeUncheckedExtrinsic) {
    // Address, Call, Signature, Extra
    const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;
    const siAddress = lookup.getSiType(addrParam.type.unwrap());
    const siSignature = lookup.getSiType(sigParam.type.unwrap());
    const nsSignature = createNamespace(siSignature);
    let nsAccountId = createNamespace(siAddress);
    const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress'; // With multiaddress, we check the first type param again

    if (isMultiAddress) {
      // AccountId, AccountIndex
      const [idParam] = siAddress.params;
      nsAccountId = createNamespace(lookup.getSiType(idParam.type.unwrap()));
    }

    lookup.registry.register({
      AccountId: ['sp_core::crypto::AccountId32'].includes(nsAccountId) ? 'AccountId32' : ['account::AccountId20', 'primitive_types::H160'].includes(nsAccountId) ? 'AccountId20' : 'AccountId32',
      // other, default to AccountId32
      Address: isMultiAddress ? 'MultiAddress' : 'AccountId',
      ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'
    });
  }
} // this extracts aliases based on what we know the runtime config looks like in a
// Substrate chain. Specifically we want to have access to the Call and Event params


function extractAliases(params, isContract) {
  const hasParams = Object.keys(params).some(k => !k.startsWith('Pallet'));
  const alias = {};

  if (params.SpRuntimeUncheckedExtrinsic) {
    // Address, Call, Signature, Extra
    const [, {
      type
    }] = params.SpRuntimeUncheckedExtrinsic;
    alias[type.unwrap().toNumber()] = 'Call';
  } else if (hasParams && !isContract) {
    l.warn('Unable to determine runtime Call type, cannot inspect sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic');
  }

  if (params.FrameSystemEventRecord) {
    // Event, Topic
    const [{
      type
    }] = params.FrameSystemEventRecord;
    alias[type.unwrap().toNumber()] = 'Event';
  } else if (hasParams && !isContract) {
    l.warn('Unable to determine runtime Event type, cannot inspect frame_system::EventRecord');
  }

  return alias;
}

function extractTypeInfo(lookup, portable) {
  const nameInfo = [];
  const types = {};

  for (let i = 0; i < portable.length; i++) {
    const type = portable[i];
    const extracted = extractName(portable, portable[i]);

    if (extracted) {
      nameInfo.push(extracted);
    }

    types[type.id.toNumber()] = type;
  }

  const dedup = removeDuplicateNames(lookup, nameInfo);
  const lookups = {};
  const names = {};
  const params = {};

  for (let i = 0; i < dedup.length; i++) {
    const [lookupIndex, name, p] = dedup[i];
    names[lookupIndex] = name;
    lookups[name] = lookup.registry.createLookupType(lookupIndex);
    params[name] = p;
  }

  return [types, lookups, names, params];
}

var _alias = /*#__PURE__*/_classPrivateFieldLooseKey("alias");

var _lookups = /*#__PURE__*/_classPrivateFieldLooseKey("lookups");

var _names = /*#__PURE__*/_classPrivateFieldLooseKey("names");

var _params = /*#__PURE__*/_classPrivateFieldLooseKey("params");

var _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey("typeDefs");

var _types = /*#__PURE__*/_classPrivateFieldLooseKey("types");

var _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey("createSiDef");

var _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey("getLookupId");

var _extract = /*#__PURE__*/_classPrivateFieldLooseKey("extract");

var _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey("extractArray");

var _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey("extractBitSequence");

var _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey("extractCompact");

var _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey("extractComposite");

var _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey("extractCompositeSet");

var _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey("extractFields");

var _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey("extractFieldsAlias");

var _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey("extractHistoric");

var _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey("extractPrimitive");

var _extractAliasPath = /*#__PURE__*/_classPrivateFieldLooseKey("extractAliasPath");

var _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey("extractSequence");

var _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey("extractTuple");

var _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey("extractVariant");

var _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey("extractVariantEnum");

export class PortableRegistry extends Struct {
  constructor(registry, value, isContract) {
    // console.time('PortableRegistry')
    super(registry, {
      types: 'Vec<PortableType>'
    }, value);
    Object.defineProperty(this, _extractVariantEnum, {
      value: _extractVariantEnum2
    });
    Object.defineProperty(this, _extractVariant, {
      value: _extractVariant2
    });
    Object.defineProperty(this, _extractTuple, {
      value: _extractTuple2
    });
    Object.defineProperty(this, _extractSequence, {
      value: _extractSequence2
    });
    Object.defineProperty(this, _extractAliasPath, {
      value: _extractAliasPath2
    });
    Object.defineProperty(this, _extractPrimitive, {
      value: _extractPrimitive2
    });
    Object.defineProperty(this, _extractHistoric, {
      value: _extractHistoric2
    });
    Object.defineProperty(this, _extractFieldsAlias, {
      value: _extractFieldsAlias2
    });
    Object.defineProperty(this, _extractFields, {
      value: _extractFields2
    });
    Object.defineProperty(this, _extractCompositeSet, {
      value: _extractCompositeSet2
    });
    Object.defineProperty(this, _extractComposite, {
      value: _extractComposite2
    });
    Object.defineProperty(this, _extractCompact, {
      value: _extractCompact2
    });
    Object.defineProperty(this, _extractBitSequence, {
      value: _extractBitSequence2
    });
    Object.defineProperty(this, _extractArray, {
      value: _extractArray2
    });
    Object.defineProperty(this, _extract, {
      value: _extract2
    });
    Object.defineProperty(this, _getLookupId, {
      value: _getLookupId2
    });
    Object.defineProperty(this, _createSiDef, {
      value: _createSiDef2
    });
    Object.defineProperty(this, _alias, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _lookups, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _names, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _params, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _typeDefs, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _types, {
      writable: true,
      value: void 0
    });
    const [types, lookups, names, _params2] = extractTypeInfo(this, this.types);
    _classPrivateFieldLooseBase(this, _alias)[_alias] = extractAliases(_params2, isContract);
    _classPrivateFieldLooseBase(this, _lookups)[_lookups] = lookups;
    _classPrivateFieldLooseBase(this, _names)[_names] = names;
    _classPrivateFieldLooseBase(this, _params)[_params] = _params2;
    _classPrivateFieldLooseBase(this, _types)[_types] = types; // console.timeEnd('PortableRegistry')
  }

  get names() {
    return Object.values(_classPrivateFieldLooseBase(this, _names)[_names]);
  }
  /**
   * @description The types of the registry
   */


  get types() {
    return this.getT('types');
  }

  register() {
    registerTypes(this, _classPrivateFieldLooseBase(this, _lookups)[_lookups], _classPrivateFieldLooseBase(this, _names)[_names], _classPrivateFieldLooseBase(this, _params)[_params]);
  }
  /**
   * @description Returns the name for a specific lookup
   */


  getName(lookupId) {
    return _classPrivateFieldLooseBase(this, _names)[_names][_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];
  }
  /**
   * @description Finds a specific type in the registry
   */


  getSiType(lookupId) {
    // NOTE catch-22 - this may already be used as part of the constructor, so
    // ensure that we have actually initialized it correctly
    const found = (_classPrivateFieldLooseBase(this, _types)[_types] || this.types)[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];

    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
    return found.type;
  }
  /**
   * @description Lookup the type definition for the index
   */


  getTypeDef(lookupId) {
    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);

    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {
      const lookupName = _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex];

      const empty = {
        info: TypeDefInfo.DoNotConstruct,
        lookupIndex,
        lookupName,
        type: this.registry.createLookupType(lookupIndex)
      }; // Set named items since we will get into circular lookups along the way

      if (lookupName) {
        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
      }

      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end


      if (!lookupName) {
        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
      }

      Object.keys(extracted).forEach(k => {
        if (k !== 'lookupName' || extracted[k]) {
          // these are safe since we are looking through the keys as set
          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];
        }
      }); // don't set lookupName on lower-level, we want to always direct to the type

      if (extracted.info === TypeDefInfo.Plain) {
        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
      }
    }

    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];
  }

}

function _createSiDef2(lookupId) {
  const typeDef = this.getTypeDef(lookupId);
  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types

  return [TypeDefInfo.DoNotConstruct, TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {
    docs: typeDef.docs,
    info: TypeDefInfo.Si,
    lookupIndex,
    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],
    type: this.registry.createLookupType(lookupId)
  } : typeDef;
}

function _getLookupId2(lookupId) {
  if (isString(lookupId)) {
    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);
    return parseInt(lookupId.replace('Lookup', ''), 10);
  } else if (isNumber(lookupId)) {
    return lookupId;
  }

  return lookupId.toNumber();
}

function _extract2(type, lookupIndex) {
  const namespace = [...type.path].join('::');
  let typeDef;
  const aliasType = _classPrivateFieldLooseBase(this, _alias)[_alias][lookupIndex] || getAliasPath(type.path);

  try {
    if (aliasType) {
      typeDef = _classPrivateFieldLooseBase(this, _extractAliasPath)[_extractAliasPath](lookupIndex, aliasType);
    } else {
      switch (type.def.type) {
        case 'Array':
          typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
          break;

        case 'BitSequence':
          typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);
          break;

        case 'Compact':
          typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
          break;

        case 'Composite':
          typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);
          break;

        case 'HistoricMetaCompat':
          typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);
          break;

        case 'Primitive':
          typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
          break;

        case 'Sequence':
          typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
          break;

        case 'Tuple':
          typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
          break;

        case 'Variant':
          typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
          break;

        default:
          assertUnreachable(type.def.type);
      }
    }
  } catch (error) {
    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);
  }

  return objectSpread({
    docs: sanitizeDocs(type.docs),
    namespace
  }, typeDef);
}

function _extractArray2(_, {
  len: length,
  type
}) {
  assert(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');
  return withTypeString(this.registry, {
    info: TypeDefInfo.VecFixed,
    length: length.toNumber(),
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)
  });
}

function _extractBitSequence2(_, {
  bitOrderType,
  bitStoreType
}) {
  // With the v3 of scale-info this swapped around, but obviously the decoder cannot determine
  // the order. With that in-mind, we apply a detection for LSb0/Msb and set accordingly
  const a = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);

  const b = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType);

  const [bitOrder, bitStore] = ['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(a.namespace || '') ? [a, b] : [b, a]; // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not
  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather
  // we don't pass it though at all

  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);
  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);
  return {
    info: TypeDefInfo.Plain,
    type: 'BitVec'
  };
}

function _extractCompact2(_, {
  type
}) {
  return withTypeString(this.registry, {
    info: TypeDefInfo.Compact,
    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)
  });
}

function _extractComposite2(lookupIndex, {
  params,
  path
}, {
  fields
}) {
  const pathFirst = path[0].toString();
  const pathLast = path[path.length - 1].toString();

  if (path.length === 1 && pathFirst === 'BTreeMap') {
    return withTypeString(this.registry, {
      info: TypeDefInfo.BTreeMap,
      sub: params.map(({
        type
      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))
    });
  } else if (['Range', 'RangeInclusive'].includes(pathFirst)) {
    return withTypeString(this.registry, {
      info: pathFirst === 'Range' ? TypeDefInfo.Range : TypeDefInfo.RangeInclusive,
      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
      type: pathFirst
    });
  } else if (['WrapperKeepOpaque', 'WrapperOpaque'].includes(pathLast)) {
    return withTypeString(this.registry, {
      info: pathLast === 'WrapperKeepOpaque' ? TypeDefInfo.WrapperKeepOpaque : TypeDefInfo.WrapperOpaque,
      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap()),
      type: pathLast
    });
  }

  return PATHS_SET.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);
}

function _extractCompositeSet2(_, params, fields) {
  assert(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');
  return withTypeString(this.registry, {
    info: TypeDefInfo.Set,
    length: this.registry.createTypeUnsafe(this.registry.createLookupType(fields[0].type), []).bitLength(),
    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({
      index,
      name
    }) => ({
      // This will be an issue > 2^53 - 1 ... don't have those (yet)
      index: index.toNumber(),
      info: TypeDefInfo.Plain,
      name: name.toString(),
      type: 'Null'
    }))
  });
}

function _extractFields2(lookupIndex, fields) {
  let isStruct = true;
  let isTuple = true;

  for (let f = 0; f < fields.length; f++) {
    const {
      name
    } = fields[f];
    isStruct = isStruct && name.isSome;
    isTuple = isTuple && name.isNone;
  }

  assert(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');

  if (fields.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: 'Null'
    };
  } else if (isTuple && fields.length === 1) {
    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);

    return objectSpread({}, typeDef, lookupIndex === -1 ? {} : {
      lookupIndex,
      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],
      lookupNameRoot: typeDef.lookupName
    }, fields[0].typeName.isSome ? {
      typeName: sanitize(fields[0].typeName.unwrap())
    } : null);
  }

  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);

  return withTypeString(this.registry, objectSpread({
    info: isTuple // Tuple check first
    ? TypeDefInfo.Tuple : TypeDefInfo.Struct
  }, alias.size ? {
    alias
  } : null, lookupIndex === -1 ? {} : {
    lookupIndex,
    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]
  }, {
    sub
  }));
}

function _extractFieldsAlias2(fields) {
  const alias = new Map();
  const sub = new Array(fields.length);

  for (let i = 0; i < fields.length; i++) {
    const {
      docs,
      name,
      type,
      typeName
    } = fields[i];

    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);

    if (name.isNone) {
      sub[i] = typeDef;
    } else {
      let nameField = stringCamelCase(name.unwrap());
      let nameOrig = null;

      if (nameField.includes('#')) {
        nameOrig = nameField;
        nameField = nameOrig.replace(/#/g, '_');
      } else if (RESERVED.includes(nameField)) {
        nameOrig = nameField;
        nameField = `${nameField}_`;
      }

      if (nameOrig) {
        alias.set(nameField, nameOrig);
      }

      sub[i] = objectSpread({}, typeDef, {
        docs: sanitizeDocs(docs),
        name: nameField
      }, typeName.isSome ? {
        typeName: sanitize(typeName.unwrap())
      } : null);
    }
  }

  return [sub, alias];
}

function _extractHistoric2(_, type) {
  return objectSpread({}, getTypeDef(type), {
    displayName: type.toString(),
    isFromSi: true
  });
}

function _extractPrimitive2(_, type) {
  const typeStr = type.def.asPrimitive.type.toString();
  return {
    info: TypeDefInfo.Plain,
    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
  };
}

function _extractAliasPath2(_, type) {
  return {
    info: TypeDefInfo.Plain,
    type
  };
}

function _extractSequence2(lookupIndex, {
  type
}) {
  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);

  if (sub.type === 'u8') {
    return {
      info: TypeDefInfo.Plain,
      type: 'Bytes'
    };
  }

  return withTypeString(this.registry, {
    info: TypeDefInfo.Vec,
    lookupIndex,
    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],
    sub
  });
}

function _extractTuple2(lookupIndex, ids) {
  if (ids.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: 'Null'
    };
  } else if (ids.length === 1) {
    return this.getTypeDef(ids[0]);
  }

  const sub = ids.map(t => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](t));
  return withTypeString(this.registry, {
    info: TypeDefInfo.Tuple,
    lookupIndex,
    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],
    sub
  });
}

function _extractVariant2(lookupIndex, {
  params,
  path
}, {
  variants
}) {
  const specialVariant = path[0].toString();

  if (specialVariant === 'Option') {
    return withTypeString(this.registry, {
      info: TypeDefInfo.Option,
      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
    });
  } else if (specialVariant === 'Result') {
    return withTypeString(this.registry, {
      info: TypeDefInfo.Result,
      sub: params.map(({
        type
      }, index) => objectSpread({
        name: ['Ok', 'Error'][index]
      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())))
    });
  } else if (variants.length === 0) {
    return {
      info: TypeDefInfo.Null,
      type: 'Null'
    };
  }

  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);
}

function _extractVariantEnum2(lookupIndex, variants) {
  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled
  // NOTE: Since we mutate, use a copy of the array as an input

  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({
    fields,
    index,
    name
  }) => {
    const desired = index.toNumber();

    while (sub.length !== desired) {
      sub.push({
        index: sub.length,
        info: TypeDefInfo.Null,
        name: `__Unused${sub.length}`,
        type: 'Null'
      });
    }

    sub.push(objectSpread(_classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields), {
      index: index.toNumber(),
      name: name.toString()
    }));
  });
  return withTypeString(this.registry, {
    info: TypeDefInfo.Enum,
    lookupIndex,
    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],
    sub
  });
}