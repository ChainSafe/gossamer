"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Metadata = void 0;

var _util = require("@polkadot/util");

var _MetadataVersioned = require("./MetadataVersioned.cjs");

// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
// magic u32 preceding the version id
const VERSION_IDX = 4; // magic + lowest supported version

const EMPTY_METADATA = new Uint8Array([0x6d, 0x65, 0x74, 0x61, 9]);

function toU8a(value) {
  return (0, _util.isHex)(value) ? toU8a((0, _util.u8aToU8a)(value)) : value.length === 0 ? EMPTY_METADATA : value;
}

function decodeU8a(registry, value) {
  try {
    return new _MetadataVersioned.MetadataVersioned(registry, value);
  } catch (error) {
    // This is an f-ing hack as a follow-up to another ugly hack
    // https://github.com/polkadot-js/api/commit/a9211690be6b68ad6c6dad7852f1665cadcfa5b2
    // when we fail on V9, try to re-parse it as v10... yes... HACK
    if (value[VERSION_IDX] === 9) {
      value[VERSION_IDX] = 10;
      return decodeU8a(registry, value);
    }

    throw error;
  }
}
/**
 * @name Metadata
 * @description
 * The versioned runtime metadata as a decoded structure
 */


class Metadata extends _MetadataVersioned.MetadataVersioned {
  constructor(registry, value) {
    super(registry, (0, _util.isU8a)(value) || (0, _util.isHex)(value) ? decodeU8a(registry, toU8a(value)) : new _MetadataVersioned.MetadataVersioned(registry, value));
  }

}

exports.Metadata = Metadata;