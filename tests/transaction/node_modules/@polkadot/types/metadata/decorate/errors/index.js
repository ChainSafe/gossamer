// Copyright 2017-2022 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { lazyMethod, objectSpread, stringCamelCase } from '@polkadot/util';
import { lazyVariants } from "../../../create/lazy.js";
import { objectNameToString } from "../util.js";
export function variantToMeta(lookup, variant) {
  return objectSpread({
    args: variant.fields.map(({
      type
    }) => lookup.getTypeDef(type).type)
  }, variant);
}
/** @internal */

export function decorateErrors(registry, {
  lookup,
  pallets
}, version) {
  const result = {};

  for (let i = 0; i < pallets.length; i++) {
    const {
      errors,
      index,
      name
    } = pallets[i];

    if (errors.isSome) {
      const sectionIndex = version >= 12 ? index.toNumber() : i;
      lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, errors.unwrap(), objectNameToString, variant => ({
        is: ({
          error,
          index
        }) => index.eq(sectionIndex) && error.eq(variant.index),
        meta: registry.createTypeUnsafe('ErrorMetadataLatest', [variantToMeta(lookup, variant)])
      })));
    }
  }

  return result;
}