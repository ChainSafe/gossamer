// Code generated by mockery v2.8.0. DO NOT EDIT.

package mocks

import (
	types "github.com/ChainSafe/gossamer/dot/types"
	mock "github.com/stretchr/testify/mock"
)

// EpochState is an autogenerated mock type for the EpochState type
type EpochState struct {
	mock.Mock
}

// GetConfigData provides a mock function with given fields: epoch
func (_m *EpochState) GetConfigData(epoch uint64) (*types.ConfigData, error) {
	ret := _m.Called(epoch)

	var r0 *types.ConfigData
	if rf, ok := ret.Get(0).(func(uint64) *types.ConfigData); ok {
		r0 = rf(epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ConfigData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentEpoch provides a mock function with given fields:
func (_m *EpochState) GetCurrentEpoch() (uint64, error) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEpochData provides a mock function with given fields: epoch
func (_m *EpochState) GetEpochData(epoch uint64) (*types.EpochData, error) {
	ret := _m.Called(epoch)

	var r0 *types.EpochData
	if rf, ok := ret.Get(0).(func(uint64) *types.EpochData); ok {
		r0 = rf(epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.EpochData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEpochForBlock provides a mock function with given fields: header
func (_m *EpochState) GetEpochForBlock(header *types.Header) (uint64, error) {
	ret := _m.Called(header)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(*types.Header) uint64); ok {
		r0 = rf(header)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.Header) error); ok {
		r1 = rf(header)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestEpochData provides a mock function with given fields:
func (_m *EpochState) GetLatestEpochData() (*types.EpochData, error) {
	ret := _m.Called()

	var r0 *types.EpochData
	if rf, ok := ret.Get(0).(func() *types.EpochData); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.EpochData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStartSlotForEpoch provides a mock function with given fields: epoch
func (_m *EpochState) GetStartSlotForEpoch(epoch uint64) (uint64, error) {
	ret := _m.Called(epoch)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(uint64) uint64); ok {
		r0 = rf(epoch)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasConfigData provides a mock function with given fields: epoch
func (_m *EpochState) HasConfigData(epoch uint64) (bool, error) {
	ret := _m.Called(epoch)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(epoch)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasEpochData provides a mock function with given fields: epoch
func (_m *EpochState) HasEpochData(epoch uint64) (bool, error) {
	ret := _m.Called(epoch)

	var r0 bool
	if rf, ok := ret.Get(0).(func(uint64) bool); ok {
		r0 = rf(epoch)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetCurrentEpoch provides a mock function with given fields: epoch
func (_m *EpochState) SetCurrentEpoch(epoch uint64) error {
	ret := _m.Called(epoch)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(epoch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetEpochData provides a mock function with given fields: _a0, _a1
func (_m *EpochState) SetEpochData(_a0 uint64, _a1 *types.EpochData) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64, *types.EpochData) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetFirstSlot provides a mock function with given fields: slot
func (_m *EpochState) SetFirstSlot(slot uint64) error {
	ret := _m.Called(slot)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint64) error); ok {
		r0 = rf(slot)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SkipVerify provides a mock function with given fields: _a0
func (_m *EpochState) SkipVerify(_a0 *types.Header) (bool, error) {
	ret := _m.Called(_a0)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*types.Header) bool); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.Header) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
