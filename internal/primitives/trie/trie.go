package trie

import (
	"slices"

	hashdb "github.com/ChainSafe/gossamer/internal/hash-db"
	memorydb "github.com/ChainSafe/gossamer/internal/memory-db"
	"github.com/ChainSafe/gossamer/internal/primitives/runtime"
	triedb "github.com/ChainSafe/gossamer/internal/trie-db"
)

// / Reexport from `hash_db`, with genericity set for `Hasher` trait.
// / This uses a noops `KeyFunction` (key addressing must be hashed or using
// / an encoding scheme that avoid key conflict).
// pub type MemoryDB<H> = memory_db::MemoryDB<H, memory_db::HashKey<H>, trie_db::DBValue>;
type PrefixedMemoryDB[Hash runtime.Hash, Hasher hashdb.Hasher[Hash]] memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue]

func NewPrefixedMemoryDB[Hash runtime.Hash, Hasher hashdb.Hasher[Hash]]() PrefixedMemoryDB[Hash, Hasher] {
	return PrefixedMemoryDB[Hash, Hasher](memorydb.NewMemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue]([]byte{0}))
}

func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Get(key Hash, prefix hashdb.Prefix) *triedb.DBValue {
	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue](*pmdb)
	return memdb.Get(key, prefix)
}

func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Insert(prefix hashdb.Prefix, value []byte) Hash {
	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue](*pmdb)
	h := memdb.Insert(prefix, value)
	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
	return h
}

func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Emplace(key Hash, prefix hashdb.Prefix, value triedb.DBValue) {
	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue](*pmdb)
	memdb.Emplace(key, prefix, value)
	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
}

func (pmdb *PrefixedMemoryDB[Hash, Hasher]) Remove(key Hash, prefix hashdb.Prefix) {
	memdb := memorydb.MemoryDB[Hash, Hasher, Hash, memorydb.HashKey[Hash], triedb.DBValue](*pmdb)
	memdb.Remove(key, prefix)
	*pmdb = PrefixedMemoryDB[Hash, Hasher](memdb)
}

// pub type TrieHash<L> = <<L as TrieLayout>::Hash as Hasher>::Out;

// / Builder for creating a [`TrieDB`].
// pub type TrieDBBuilder<'a, 'cache, L> = trie_db::TrieDBBuilder<'a, 'cache, L>;
// type TrieDBBuilder[Hash, DB, Cache, Layout any] triedb.TrieDBBuilder[Hash, DB, Cache, Layout]

// / Verify a set of key-value pairs against a trie root and a proof.
// /
// / Checks a set of keys with optional values for inclusion in the proof that was generated by
// / `generate_trie_proof`.
// / If the value in the pair is supplied (`(key, Some(value))`), this key-value pair will be
// / checked for inclusion in the proof.
// / If the value is omitted (`(key, None)`), this key will be checked for non-inclusion in the
// / proof.
func VerifyTrieProof[TrieHash comparable](
	root TrieHash,
	proof [][]byte,
	items []struct {
		Key   []byte
		Value *[]byte
	},
) error {
	panic("unimpl")
}

// / Determine a trie root given a hash DB and delta values.
// pub fn delta_trie_root<L: TrieConfiguration, I, A, B, DB, V>(
//
//	db: &mut DB,
//	mut root: TrieHash<L>,
//	delta: I,
//	recorder: Option<&mut dyn trie_db::TrieRecorder<TrieHash<L>>>,
//	cache: Option<&mut dyn TrieCache<L::Codec>>,
//
// ) -> Result<TrieHash<L>, Box<TrieError<L>>>
func DeltaTrieRoot[TrieHash comparable](
	db hashdb.HashDB[TrieHash, triedb.DBValue],
	root TrieHash,
	delta []struct {
		Key   []byte
		Value *[]byte
	},
	recorder triedb.TrieRecorder,
	cache triedb.TrieCache,
) (TrieHash, error) {
	trie := triedb.NewTrieDBMutBuilderFromExisting[TrieHash](db, root).Build()

	slices.SortStableFunc(delta, func(a struct {
		Key   []byte
		Value *[]byte
	}, b struct {
		Key   []byte
		Value *[]byte
	}) int {
		if string(a.Key) < string(b.Key) {
			return -1
		} else if string(a.Key) == string(b.Key) {
			return 0
		} else {
			return 1
		}
	})

	for _, kv := range delta {
		if kv.Value != nil {
			trie.Insert(kv.Key, *kv.Value)
		} else {
			trie.Remove(kv.Key)
		}
	}

	return root, nil
}

// / Read a value from the trie.
// pub fn read_trie_value<L: TrieLayout, DB: hash_db::HashDBRef<L::Hash, trie_db::DBValue>>(
//
//	db: &DB,
//	root: &TrieHash<L>,
//	key: &[u8],
//	recorder: Option<&mut dyn TrieRecorder<TrieHash<L>>>,
//	cache: Option<&mut dyn TrieCache<L::Codec>>,
//
// ) -> Result<Option<Vec<u8>>, Box<TrieError<L>>> {
func ReadTrieValue[TrieHash comparable](
	db hashdb.HashDBRef[TrieHash, triedb.DBValue],
	root TrieHash,
	key []byte,
	recorder triedb.TrieRecorder,
	cache triedb.TrieCache,
) (*[]byte, error) {
	//		TrieDBBuilder::<L>::new(db, root)
	//			.with_optional_cache(cache)
	//			.with_optional_recorder(recorder)
	//			.build()
	//			.get(key)
	//	}
	dbVal, err := triedb.NewTrieDBBuilder[TrieHash](db, root).Build().Get(key)
	if dbVal == nil {
		return nil, err
	}
	val := []byte(*dbVal)
	return &val, err
}

type KeySpacedDB[Hash comparable, T any] struct {
	DB     hashdb.HashDB[Hash, T]
	Prefix []byte
}

func NewKeySpacedDB[Hash comparable, T any](db hashdb.HashDB[Hash, T], ks []byte) KeySpacedDB[Hash, T] {
	return KeySpacedDB[Hash, T]{
		DB:     db,
		Prefix: ks,
	}
}

func (tbe *KeySpacedDB[H, T]) Get(key H, prefix hashdb.Prefix) *T {
	panic("unimpl")
}

func (tbe *KeySpacedDB[H, T]) Contains(key H, prefix hashdb.Prefix) bool {
	return tbe.Get(key, prefix) != nil
}

func (tbe *KeySpacedDB[H, T]) Insert(prefix hashdb.Prefix, value []byte) H {
	panic("unimplemented")
}

func (tbe *KeySpacedDB[H, T]) Emplace(key H, prefix hashdb.Prefix, value T) {
	panic("unimplemented")
}

func (tbe *KeySpacedDB[H, T]) Remove(key H, prefix hashdb.Prefix) {
	panic("unimplemented")
}
