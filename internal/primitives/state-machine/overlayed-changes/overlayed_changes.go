package overlayedchanges

import (
	"github.com/ChainSafe/gossamer/internal/primitives/core/offchain"
	"github.com/ChainSafe/gossamer/internal/primitives/runtime"
)

// / Storage key.
// pub type StorageKey = Vec<u8>;
type StorageKey []byte

// / Storage value.
// pub type StorageValue = Vec<u8>;
type StorageValue []byte

// / In memory array of storage values.
// pub type StorageCollection = Vec<(StorageKey, Option<StorageValue>)>;
type StorageCollection []struct {
	StorageKey
	StorageValue
}

// / In memory arrays of storage values for multiple child tries.
// pub type ChildStorageCollection = Vec<(StorageKey, StorageCollection)>;
type ChildStorageCollection []struct {
	StorageKey
	StorageCollection
}

// / In memory array of storage values.
// pub type OffchainChangesCollection = Vec<((Vec<u8>, Vec<u8>), OffchainOverlayedChange)>;
type OffchainChangesCollection []struct {
	PrefixKey struct {
		Prefix []byte
		Key    []byte
	}
	ValueOperation offchain.OffchainOverlayedChange
}

// / The set of changes that are overlaid onto the backend.
// /
// / It allows changes to be modified using nestable transactions.
// #[derive(Debug, Default, Clone)]
// pub struct OverlayedChanges {
type OverlayedChanges struct {
	// /// Top level storage changes.
	// top: OverlayedChangeSet,
	// /// Child storage changes. The map key is the child storage key without the common prefix.
	// children: Map<StorageKey, (OverlayedChangeSet, ChildInfo)>,
	// /// Offchain related changes.
	// offchain: OffchainOverlayedChanges,
	// /// Transaction index changes,
	// transaction_index_ops: Vec<IndexOperation>,
	// /// True if extrinsics stats must be collected.
	// collect_extrinsics: bool,
	// /// Collect statistic on this execution.
	// stats: StateMachineStats,
}

// / Transaction index operation.
type IndexOperations interface {
	IndexOperationInsert | IndexOperationRenew
}

// / Transaction index operation.
type IndexOperation any

// / Insert transaction into index.
type IndexOperationInsert struct {
	/// Extrinsic index in the current block.
	Extrinsic uint32
	/// Data content hash.
	Hash []byte
	/// Indexed data size.
	Size uint32
}

// / Renew existing transaction storage.
type IndexOperationRenew struct {
	/// Extrinsic index in the current block.
	Extrinsic uint32
	/// Referenced index hash.
	Hash []byte
}

// / A storage changes structure that can be generated by the data collected in [`OverlayedChanges`].
// /
// / This contains all the changes to the storage and transactions to apply theses changes to the
// / backend.
// pub struct StorageChanges<Transaction, H: Hasher> {
type StorageChanges[Transaction, H any] struct {
	/// All changes to the main storage.
	///
	/// A value of `None` means that it was deleted.
	// pub main_storage_changes: StorageCollection,
	MainStorageChanges StorageCollection
	/// All changes to the child storages.
	// pub child_storage_changes: ChildStorageCollection,
	ChildStorageChanges ChildStorageCollection
	/// Offchain state changes to write to the offchain database.
	// pub offchain_storage_changes: OffchainChangesCollection,
	OffchainStorageChanges OffchainChangesCollection
	/// A transaction for the backend that contains all changes from
	/// [`main_storage_changes`](StorageChanges::main_storage_changes) and from
	/// [`child_storage_changes`](StorageChanges::child_storage_changes).
	/// [`offchain_storage_changes`](StorageChanges::offchain_storage_changes).
	// pub transaction: Transaction,
	Transaction Transaction
	/// The storage root after applying the transaction.
	// pub transaction_storage_root: H::Out,
	TransactionStorageRoot H
	/// Changes to the transaction index,
	// pub transaction_index_changes: Vec<IndexOperation>,
	TransactionIndexChanges []IndexOperation
}

// / Storage transactions are calculated as part of the `storage_root`.
// / These transactions can be reused for importing the block into the
// / storage. So, we cache them to not require a recomputation of those transactions.
// pub struct StorageTransactionCache<Transaction, H: Hasher> {
type StorageTransactionCache[Transaction any, H runtime.Hash] struct {
	// /// Contains the changes for the main and the child storages as one transaction.
	// pub(crate) transaction: Option<Transaction>,
	Transaction *Transaction
	// /// The storage root after applying the transaction.
	// pub(crate) transaction_storage_root: Option<H::Out>,
	TransactionStorageRoot H
}
