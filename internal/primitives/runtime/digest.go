// Copyright 2024 ChainSafe Systems (ON)
// SPDX-License-Identifier: LGPL-3.0-only

package runtime

// Digest item that is able to encode/decode 'system' digest items and
// provide opaque access to other items.
type DigestItemTypes interface {
	PreRuntime | Consensus | Seal | Other | RuntimeEnvironmentUpdated
}

// Digest item that is able to encode/decode 'system' digest items and
// provide opaque access to other items.
type DigestItem any

// NewDigestItem is constructor for DigestItem
func NewDigestItem[T DigestItemTypes](item T) DigestItem {
	return NewDigestItem(item)
}

// A pre-runtime digest.
//
// These are messages from the consensus engine to the runtime, although
// the consensus engine can (and should) read them itself to avoid
// code and state duplication. It is erroneous for a runtime to produce
// these, but this is not (yet) checked.
//
// NOTE: the runtime is not allowed to panic or fail in an `on_initialize`
// call if an expected `PreRuntime` digest is not present. It is the
// responsibility of a external block verifier to check this. Runtime API calls
// will initialize the block without pre-runtime digests, so initialization
// cannot fail when they are missing.
type PreRuntime struct {
	ConsensusEngineID
	Bytes []byte
}

// A message from the runtime to the consensus engine. This should *never*
// be generated by the native code of any consensus engine, but this is not
// checked (yet).
type Consensus struct {
	ConsensusEngineID
	Bytes []byte
}

// Put a Seal on it. This is only used by native code, and is never seen
// by runtimes.
type Seal struct {
	ConsensusEngineID
	Bytes []byte
}

// Some other thing. Unsupported and experimental.
type Other []byte

// An indication for the light clients that the runtime execution
// environment is updated.
type RuntimeEnvironmentUpdated struct{}

// Digest is a header digest.
type Digest struct {
	// A list of logs in the digest.
	Logs []DigestItem
}

// Push new digest item.
func (d *Digest) Push(item DigestItem) {
	d.Logs = append(d.Logs, item)
}

// Pop a digest item.
func (d *Digest) Pop() DigestItem {
	if len(d.Logs) == 0 {
		return nil
	}
	item := d.Logs[len(d.Logs)-1]
	d.Logs = d.Logs[:len(d.Logs)-1]
	return item
}
