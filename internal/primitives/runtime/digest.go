package runtime

// / Digest item that is able to encode/decode 'system' digest items and
// / provide opaque access to other items.
type DigestItems interface {
	PreRuntime | Consensus | Seal | Other | RuntimeEnvironmentUpdated
}

// / Digest item that is able to encode/decode 'system' digest items and
// / provide opaque access to other items.
type DigestItem any

// / A pre-runtime digest.
// /
// / These are messages from the consensus engine to the runtime, although
// / the consensus engine can (and should) read them itself to avoid
// / code and state duplication. It is erroneous for a runtime to produce
// / these, but this is not (yet) checked.
// /
// / NOTE: the runtime is not allowed to panic or fail in an `on_initialize`
// / call if an expected `PreRuntime` digest is not present. It is the
// / responsibility of a external block verifier to check this. Runtime API calls
// / will initialize the block without pre-runtime digests, so initialization
// / cannot fail when they are missing.
type PreRuntime struct {
	ConsensusEngineID
	Bytes []byte
}

// / A message from the runtime to the consensus engine. This should *never*
// / be generated by the native code of any consensus engine, but this is not
// / checked (yet).
type Consensus struct {
	ConsensusEngineID
	Bytes []byte
}

// / Put a Seal on it. This is only used by native code, and is never seen
// / by runtimes.
type Seal struct {
	ConsensusEngineID
	Bytes []byte
}

// / Some other thing. Unsupported and experimental.
type Other []byte

// / An indication for the light clients that the runtime execution
// / environment is updated.
// /
type RuntimeEnvironmentUpdated struct{}

// / Generic header digest.
// #[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo, Default)]
// #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
//
//	pub struct Digest {
//		/// A list of logs in the digest.
//		pub logs: Vec<DigestItem>,
//	}
type Digest struct {
	/// A list of logs in the digest.
	Logs []DigestItem
}

// impl Digest {
// 	/// Get reference to all digest items.
// 	pub fn logs(&self) -> &[DigestItem] {
// 		&self.logs
// 	}

// /// Push new digest item.
func (d *Digest) Push(item DigestItem) {
	d.Logs = append(d.Logs, item)
}

// 	pub fn push(&mut self, item: DigestItem) {
// 		self.logs.push(item);
// 	}

// 	/// Pop a digest item.
// 	pub fn pop(&mut self) -> Option<DigestItem> {
// 		self.logs.pop()
// 	}

// 	/// Get reference to the first digest item that matches the passed predicate.
// 	pub fn log<T: ?Sized, F: Fn(&DigestItem) -> Option<&T>>(&self, predicate: F) -> Option<&T> {
// 		self.logs().iter().find_map(predicate)
// 	}

// 	/// Get a conversion of the first digest item that successfully converts using the function.
// 	pub fn convert_first<T, F: Fn(&DigestItem) -> Option<T>>(&self, predicate: F) -> Option<T> {
// 		self.logs().iter().find_map(predicate)
// 	}
// }
