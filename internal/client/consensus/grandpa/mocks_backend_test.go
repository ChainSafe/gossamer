// Code generated by mockery v2.36.1. DO NOT EDIT.

package grandpa

import (
	mock "github.com/stretchr/testify/mock"
	constraints "golang.org/x/exp/constraints"
)

// BackendMock is an autogenerated mock type for the Backend type
type BackendMock[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]] struct {
	mock.Mock
}

type BackendMock_Expecter[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]] struct {
	mock *mock.Mock
}

func (_m *BackendMock[Hash, N, H, B]) EXPECT() *BackendMock_Expecter[Hash, N, H, B] {
	return &BackendMock_Expecter[Hash, N, H, B]{mock: &_m.Mock}
}

// Blockchain provides a mock function with given fields:
func (_m *BackendMock[Hash, N, H, B]) Blockchain() B {
	ret := _m.Called()

	var r0 B
	if rf, ok := ret.Get(0).(func() B); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(B)
	}

	return r0
}

// BackendMock_Blockchain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Blockchain'
type BackendMock_Blockchain_Call[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]] struct {
	*mock.Call
}

// Blockchain is a helper method to define mock.On call
func (_e *BackendMock_Expecter[Hash, N, H, B]) Blockchain() *BackendMock_Blockchain_Call[Hash, N, H, B] {
	return &BackendMock_Blockchain_Call[Hash, N, H, B]{Call: _e.mock.On("Blockchain")}
}

func (_c *BackendMock_Blockchain_Call[Hash, N, H, B]) Run(run func()) *BackendMock_Blockchain_Call[Hash, N, H, B] {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *BackendMock_Blockchain_Call[Hash, N, H, B]) Return(_a0 B) *BackendMock_Blockchain_Call[Hash, N, H, B] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BackendMock_Blockchain_Call[Hash, N, H, B]) RunAndReturn(run func() B) *BackendMock_Blockchain_Call[Hash, N, H, B] {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: key
func (_m *BackendMock[Hash, N, H, B]) Get(key Key) (*[]byte, error) {
	ret := _m.Called(key)

	var r0 *[]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(Key) (*[]byte, error)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(Key) *[]byte); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(Key) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BackendMock_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type BackendMock_Get_Call[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key Key
func (_e *BackendMock_Expecter[Hash, N, H, B]) Get(key interface{}) *BackendMock_Get_Call[Hash, N, H, B] {
	return &BackendMock_Get_Call[Hash, N, H, B]{Call: _e.mock.On("Get", key)}
}

func (_c *BackendMock_Get_Call[Hash, N, H, B]) Run(run func(key Key)) *BackendMock_Get_Call[Hash, N, H, B] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(Key))
	})
	return _c
}

func (_c *BackendMock_Get_Call[Hash, N, H, B]) Return(_a0 *[]byte, _a1 error) *BackendMock_Get_Call[Hash, N, H, B] {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *BackendMock_Get_Call[Hash, N, H, B]) RunAndReturn(run func(Key) (*[]byte, error)) *BackendMock_Get_Call[Hash, N, H, B] {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: insert, delete
func (_m *BackendMock[Hash, N, H, B]) Insert(insert []KeyValue, delete []Key) error {
	ret := _m.Called(insert, delete)

	var r0 error
	if rf, ok := ret.Get(0).(func([]KeyValue, []Key) error); ok {
		r0 = rf(insert, delete)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackendMock_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type BackendMock_Insert_Call[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]] struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - insert []KeyValue
//   - delete []Key
func (_e *BackendMock_Expecter[Hash, N, H, B]) Insert(insert interface{}, delete interface{}) *BackendMock_Insert_Call[Hash, N, H, B] {
	return &BackendMock_Insert_Call[Hash, N, H, B]{Call: _e.mock.On("Insert", insert, delete)}
}

func (_c *BackendMock_Insert_Call[Hash, N, H, B]) Run(run func(insert []KeyValue, delete []Key)) *BackendMock_Insert_Call[Hash, N, H, B] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]KeyValue), args[1].([]Key))
	})
	return _c
}

func (_c *BackendMock_Insert_Call[Hash, N, H, B]) Return(_a0 error) *BackendMock_Insert_Call[Hash, N, H, B] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *BackendMock_Insert_Call[Hash, N, H, B]) RunAndReturn(run func([]KeyValue, []Key) error) *BackendMock_Insert_Call[Hash, N, H, B] {
	_c.Call.Return(run)
	return _c
}

// NewBackendMock creates a new instance of BackendMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBackendMock[Hash constraints.Ordered, N constraints.Unsigned, H Header[Hash, N], B BlockchainBackend[Hash, N, H]](t interface {
	mock.TestingT
	Cleanup(func())
}) *BackendMock[Hash, N, H, B] {
	mock := &BackendMock[Hash, N, H, B]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
