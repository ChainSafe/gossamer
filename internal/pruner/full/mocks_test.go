// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ChainSafe/gossamer/internal/pruner/full (interfaces: JournalDatabase,Getter,PutDeleter,ChainDBNewBatcher,Logger,BlockState)

// Package full is a generated GoMock package.
package full

import (
	reflect "reflect"

	chaindb "github.com/ChainSafe/chaindb"
	common "github.com/ChainSafe/gossamer/lib/common"
	gomock "github.com/golang/mock/gomock"
)

// MockJournalDatabase is a mock of JournalDatabase interface.
type MockJournalDatabase struct {
	ctrl     *gomock.Controller
	recorder *MockJournalDatabaseMockRecorder
}

// MockJournalDatabaseMockRecorder is the mock recorder for MockJournalDatabase.
type MockJournalDatabaseMockRecorder struct {
	mock *MockJournalDatabase
}

// NewMockJournalDatabase creates a new mock instance.
func NewMockJournalDatabase(ctrl *gomock.Controller) *MockJournalDatabase {
	mock := &MockJournalDatabase{ctrl: ctrl}
	mock.recorder = &MockJournalDatabaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJournalDatabase) EXPECT() *MockJournalDatabaseMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockJournalDatabase) Get(arg0 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockJournalDatabaseMockRecorder) Get(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockJournalDatabase)(nil).Get), arg0)
}

// NewBatch mocks base method.
func (m *MockJournalDatabase) NewBatch() chaindb.Batch {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewBatch")
	ret0, _ := ret[0].(chaindb.Batch)
	return ret0
}

// NewBatch indicates an expected call of NewBatch.
func (mr *MockJournalDatabaseMockRecorder) NewBatch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatch", reflect.TypeOf((*MockJournalDatabase)(nil).NewBatch))
}

// MockGetter is a mock of Getter interface.
type MockGetter struct {
	ctrl     *gomock.Controller
	recorder *MockGetterMockRecorder
}

// MockGetterMockRecorder is the mock recorder for MockGetter.
type MockGetterMockRecorder struct {
	mock *MockGetter
}

// NewMockGetter creates a new mock instance.
func NewMockGetter(ctrl *gomock.Controller) *MockGetter {
	mock := &MockGetter{ctrl: ctrl}
	mock.recorder = &MockGetterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetter) EXPECT() *MockGetterMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockGetter) Get(arg0 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockGetterMockRecorder) Get(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockGetter)(nil).Get), arg0)
}

// MockPutDeleter is a mock of PutDeleter interface.
type MockPutDeleter struct {
	ctrl     *gomock.Controller
	recorder *MockPutDeleterMockRecorder
}

// MockPutDeleterMockRecorder is the mock recorder for MockPutDeleter.
type MockPutDeleterMockRecorder struct {
	mock *MockPutDeleter
}

// NewMockPutDeleter creates a new mock instance.
func NewMockPutDeleter(ctrl *gomock.Controller) *MockPutDeleter {
	mock := &MockPutDeleter{ctrl: ctrl}
	mock.recorder = &MockPutDeleterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPutDeleter) EXPECT() *MockPutDeleterMockRecorder {
	return m.recorder
}

// Del mocks base method.
func (m *MockPutDeleter) Del(arg0 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockPutDeleterMockRecorder) Del(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockPutDeleter)(nil).Del), arg0)
}

// Put mocks base method.
func (m *MockPutDeleter) Put(arg0, arg1 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Put", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Put indicates an expected call of Put.
func (mr *MockPutDeleterMockRecorder) Put(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockPutDeleter)(nil).Put), arg0, arg1)
}

// MockChainDBNewBatcher is a mock of ChainDBNewBatcher interface.
type MockChainDBNewBatcher struct {
	ctrl     *gomock.Controller
	recorder *MockChainDBNewBatcherMockRecorder
}

// MockChainDBNewBatcherMockRecorder is the mock recorder for MockChainDBNewBatcher.
type MockChainDBNewBatcherMockRecorder struct {
	mock *MockChainDBNewBatcher
}

// NewMockChainDBNewBatcher creates a new mock instance.
func NewMockChainDBNewBatcher(ctrl *gomock.Controller) *MockChainDBNewBatcher {
	mock := &MockChainDBNewBatcher{ctrl: ctrl}
	mock.recorder = &MockChainDBNewBatcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChainDBNewBatcher) EXPECT() *MockChainDBNewBatcherMockRecorder {
	return m.recorder
}

// NewBatch mocks base method.
func (m *MockChainDBNewBatcher) NewBatch() chaindb.Batch {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewBatch")
	ret0, _ := ret[0].(chaindb.Batch)
	return ret0
}

// NewBatch indicates an expected call of NewBatch.
func (mr *MockChainDBNewBatcherMockRecorder) NewBatch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatch", reflect.TypeOf((*MockChainDBNewBatcher)(nil).NewBatch))
}

// MockLogger is a mock of Logger interface.
type MockLogger struct {
	ctrl     *gomock.Controller
	recorder *MockLoggerMockRecorder
}

// MockLoggerMockRecorder is the mock recorder for MockLogger.
type MockLoggerMockRecorder struct {
	mock *MockLogger
}

// NewMockLogger creates a new mock instance.
func NewMockLogger(ctrl *gomock.Controller) *MockLogger {
	mock := &MockLogger{ctrl: ctrl}
	mock.recorder = &MockLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder {
	return m.recorder
}

// Debug mocks base method.
func (m *MockLogger) Debug(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Debug", arg0)
}

// Debug indicates an expected call of Debug.
func (mr *MockLoggerMockRecorder) Debug(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockLogger)(nil).Debug), arg0)
}

// Debugf mocks base method.
func (m *MockLogger) Debugf(arg0 string, arg1 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Debugf", varargs...)
}

// Debugf indicates an expected call of Debugf.
func (mr *MockLoggerMockRecorder) Debugf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debugf", reflect.TypeOf((*MockLogger)(nil).Debugf), varargs...)
}

// Errorf mocks base method.
func (m *MockLogger) Errorf(arg0 string, arg1 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Errorf", varargs...)
}

// Errorf indicates an expected call of Errorf.
func (mr *MockLoggerMockRecorder) Errorf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Errorf", reflect.TypeOf((*MockLogger)(nil).Errorf), varargs...)
}

// MockBlockState is a mock of BlockState interface.
type MockBlockState struct {
	ctrl     *gomock.Controller
	recorder *MockBlockStateMockRecorder
}

// MockBlockStateMockRecorder is the mock recorder for MockBlockState.
type MockBlockStateMockRecorder struct {
	mock *MockBlockState
}

// NewMockBlockState creates a new mock instance.
func NewMockBlockState(ctrl *gomock.Controller) *MockBlockState {
	mock := &MockBlockState{ctrl: ctrl}
	mock.recorder = &MockBlockStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBlockState) EXPECT() *MockBlockStateMockRecorder {
	return m.recorder
}

// IsDescendantOf mocks base method.
func (m *MockBlockState) IsDescendantOf(arg0, arg1 common.Hash) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDescendantOf", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDescendantOf indicates an expected call of IsDescendantOf.
func (mr *MockBlockStateMockRecorder) IsDescendantOf(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDescendantOf", reflect.TypeOf((*MockBlockState)(nil).IsDescendantOf), arg0, arg1)
}
